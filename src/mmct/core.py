from multiprocessing import Pool
import numpy as np
import numpy.typing as npt
from scipy.stats import multinomial


class tester:
	"""
	Testing class for performing Multinomial Tests using Monte Carlo simulation.

	Tests whether a given set of data, X, could have been generated by a
	hypothesised multinomial distribution.
	The distribution is parametrised by the number of bins in the multinomial
	distribution, K, the probability associated witheach case, p_i, and the total
	number of observations in each of the K bins, N.

	When the test is run, a number of random samples are drawn from the
	hypothesised distribution. The likelihood function of X under the hypothesised
	distribution is then compared to the sampled data and from this a p-value is
	calculated.
	...
	Attributes
	----------
	n_samples : int, default=1000
		The number of Monte Carlo samples to generate
	statistics : numpy.ndarray[float]
		The likelihood of the Monte Carlo samples
	fix : bool, default=False
		If True, the statistics will not be recalculated upon restarting the test.
		Useful while testing or if multiple data sets need to be tested under the
		same hypothesis (beware of bias!).

	Methods
	-------
	do_test(x, probs)
		Calculate p-value for a dataset being generated by the given multinomial
		distribution.

	Examples
	--------
	Test some sample D6-rolling data
	>>> t = mmct.tester()
	>>> t.n_samples = 80000
	>>> t.do_test(np.array([11,5,8,11,8,7]),np.array([1/6,1/6,1/6,1/6,1/6,1/6]))

	"""

	def __init__(self):
		self.n_samples = 1000
		self.statistics = np.zeros(1)
		self.fix = False

	# Generate Monte Carlo samples and calculate likelihood
	def _mc_runs(self, n_obs: int, probs: npt.NDArray[np.float_]) -> None:
		# Generate samples from hypothesised distribution
		m = multinomial.rvs(n=n_obs, p=probs, size=self.n_samples)
		# Calculate the likelihood of each sample
		self.statistics = np.array(
			[multinomial.pmf(mi, n=n_obs, p=probs) for mi in m])

	def do_test(self,
		x: npt.NDArray[np.int_], probs: npt.NDArray[np.float_]) -> float:

		if x.size != probs.size:
			raise ValueError('Input arrays must have the same number of elements')

		n_obs = np.sum(x)  # Total number of observations in x

		# Run samples if not fixed
		if not self.fix:
			self._mc_runs(n_obs, probs)

		x_stat: float = multinomial.pmf(x, n=n_obs, p=probs)

		# Count number of trials with statistic smaller than x
		n_smaller = 0
		for s in self.statistics:
			if s <= x_stat:
				n_smaller += 1
		return n_smaller / self.statistics.size


# Derived class from tester that uses multithreading to speed up the monte carlo
# sampling

class mt_tester(tester):

	# Number of threads to use. If None, the system default is used
	# (typically the number of logical processors)
	threads = None

	def _mc_runs(self) -> None:

		with Pool(processes=self.threads) as pool:
			res = pool.map(self._generate_sample_stat, range(0, self.n_samples))
		self.statistics = np.array(res)
